$date
	Thu Apr 24 17:17:42 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module dataPath_tb $end
$var wire 1 ! sign $end
$var wire 1 " overflow $end
$var wire 32 # instr [31:0] $end
$var wire 1 $ cout $end
$var wire 1 % Zero $end
$var wire 32 & WriteData [31:0] $end
$var wire 32 ' Adr [31:0] $end
$var reg 4 ( ALUControl [3:0] $end
$var reg 2 ) ALUSrcA [1:0] $end
$var reg 2 * ALUSrcB [1:0] $end
$var reg 1 + AdrSrc $end
$var reg 1 , IRWrite $end
$var reg 3 - ImmSrc [2:0] $end
$var reg 1 . PCWrite $end
$var reg 32 / ReadData [31:0] $end
$var reg 1 0 RegWrite $end
$var reg 2 1 ResultSrc [1:0] $end
$var reg 1 2 clk $end
$var reg 1 3 reset $end
$scope module dut $end
$var wire 4 4 ALUControl [3:0] $end
$var wire 2 5 ALUSrcA [1:0] $end
$var wire 2 6 ALUSrcB [1:0] $end
$var wire 1 + AdrSrc $end
$var wire 1 , IRWrite $end
$var wire 3 7 ImmSrc [2:0] $end
$var wire 1 . PCWrite $end
$var wire 32 8 ReadData [31:0] $end
$var wire 1 0 RegWrite $end
$var wire 2 9 ResultSrc [1:0] $end
$var wire 1 2 clk $end
$var wire 1 : memwrite $end
$var wire 1 3 reset $end
$var wire 1 ! sign $end
$var wire 1 " overflow $end
$var wire 32 ; instr [31:0] $end
$var wire 3 < funct3 [2:0] $end
$var wire 1 $ cout $end
$var wire 1 % Zero $end
$var wire 32 = WriteData [31:0] $end
$var wire 32 > SrcB [31:0] $end
$var wire 32 ? SrcA [31:0] $end
$var wire 32 @ Result [31:0] $end
$var wire 32 A RD2 [31:0] $end
$var wire 32 B RD1 [31:0] $end
$var wire 32 C PC [31:0] $end
$var wire 32 D OldPC [31:0] $end
$var wire 32 E ImmExt [31:0] $end
$var wire 32 F Data [31:0] $end
$var wire 32 G Adr [31:0] $end
$var wire 32 H ALUResult [31:0] $end
$var wire 32 I ALUOut [31:0] $end
$var wire 32 J A [31:0] $end
$var reg 32 K aligned_address [31:0] $end
$scope module AReg $end
$var wire 1 2 clk $end
$var wire 1 3 reset $end
$var wire 32 L d [31:0] $end
$var parameter 32 M WIDTH $end
$var reg 32 N q [31:0] $end
$upscope $end
$scope module BReg $end
$var wire 1 2 clk $end
$var wire 1 3 reset $end
$var wire 32 O d [31:0] $end
$var parameter 32 P WIDTH $end
$var reg 32 Q q [31:0] $end
$upscope $end
$scope module adrMux $end
$var wire 32 R b [31:0] $end
$var wire 1 + sel $end
$var wire 32 S out [31:0] $end
$var wire 32 T a [31:0] $end
$var parameter 32 U WIDTH $end
$upscope $end
$scope module alu $end
$var wire 4 V aluc [3:0] $end
$var wire 32 W src2 [31:0] $end
$var wire 32 X src1 [31:0] $end
$var wire 5 Y shamt [4:0] $end
$var reg 1 $ cout $end
$var reg 32 Z out [31:0] $end
$var reg 1 " overflow $end
$var reg 1 ! sign $end
$var reg 33 [ tmp [32:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module aluReg $end
$var wire 1 2 clk $end
$var wire 32 \ d [31:0] $end
$var wire 1 3 reset $end
$var parameter 32 ] WIDTH $end
$var reg 32 ^ q [31:0] $end
$upscope $end
$scope module dataReg $end
$var wire 1 2 clk $end
$var wire 32 _ d [31:0] $end
$var wire 1 3 reset $end
$var parameter 32 ` WIDTH $end
$var reg 32 a q [31:0] $end
$upscope $end
$scope module ext $end
$var wire 3 b ImmSrc [2:0] $end
$var wire 25 c instr [31:7] $end
$var wire 32 d imm_u [31:0] $end
$var wire 32 e imm_s [31:0] $end
$var wire 32 f imm_j [31:0] $end
$var wire 32 g imm_i [31:0] $end
$var wire 32 h imm_b [31:0] $end
$var reg 32 i imm_out [31:0] $end
$upscope $end
$scope module instrReg $end
$var wire 1 2 clk $end
$var wire 32 j d [31:0] $end
$var wire 1 , en $end
$var wire 1 3 reset $end
$var parameter 32 k WIDTH $end
$var reg 32 l q [31:0] $end
$upscope $end
$scope module oldPcReg $end
$var wire 1 2 clk $end
$var wire 1 , en $end
$var wire 1 3 reset $end
$var wire 32 m d [31:0] $end
$var parameter 32 n WIDTH $end
$var reg 32 o q [31:0] $end
$upscope $end
$scope module pcFlop $end
$var wire 1 2 clk $end
$var wire 1 . en $end
$var wire 1 3 reset $end
$var wire 32 p d [31:0] $end
$var parameter 32 q WIDTH $end
$var reg 32 r q [31:0] $end
$upscope $end
$scope module resultMux $end
$var wire 32 s in0 [31:0] $end
$var wire 32 t in1 [31:0] $end
$var wire 32 u in2 [31:0] $end
$var wire 32 v in3 [31:0] $end
$var wire 2 w sel [1:0] $end
$var parameter 32 x WIDTH $end
$var reg 32 y out [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 2 clk $end
$var wire 5 z rd [4:0] $end
$var wire 32 { rd1 [31:0] $end
$var wire 32 | rd2 [31:0] $end
$var wire 5 } rs1 [4:0] $end
$var wire 5 ~ rs2 [4:0] $end
$var wire 32 !" wd [31:0] $end
$var wire 1 0 we $end
$var reg 32 "" rd1_reg [31:0] $end
$var reg 32 #" rd2_reg [31:0] $end
$upscope $end
$scope module srcAmux $end
$var wire 32 $" in0 [31:0] $end
$var wire 32 %" in1 [31:0] $end
$var wire 32 &" in2 [31:0] $end
$var wire 2 '" sel [1:0] $end
$var parameter 32 (" WIDTH $end
$var reg 32 )" out [31:0] $end
$upscope $end
$scope module srcBmux $end
$var wire 32 *" in0 [31:0] $end
$var wire 32 +" in1 [31:0] $end
$var wire 32 ," in2 [31:0] $end
$var wire 2 -" sel [1:0] $end
$var parameter 32 ." WIDTH $end
$var reg 32 /" out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 ."
b100000 ("
b100000 x
b100000 q
b100000 n
b100000 k
b100000 `
b100000 ]
b100000 U
b100000 P
b100000 M
$end
#0
$dumpvars
b0 /"
bx -"
b100 ,"
b0 +"
bx *"
b0 )"
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
bx y
bx w
b0 v
b0 u
bx t
bx s
bx r
bx p
bx o
bx m
bx l
bx j
b0 i
bx0 h
bx g
bx0 f
bx e
bx000000000000 d
bx c
bx b
bx a
bx _
bx ^
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
bx V
bx T
bx S
bx R
bx Q
bx O
bx N
bx L
bx K
bx J
bx I
b0 H
bx G
bx F
b0 E
bx D
bx C
bx B
bx A
bx @
b0 ?
b0 >
bx =
bx <
bx ;
0:
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
03
02
bx 1
x0
bx /
x.
bx -
x,
x+
bx *
bx )
bx (
bx '
bx &
1%
0$
bx #
0"
0!
$end
#5
b0 K
b0 R
b0 I
b0 ^
b0 s
12
#10
13
02
#15
b0 g
b0 e
b0 h
b0 d
b0 f
b0 c
b0 z
b0 ~
b0 }
b0 <
b0 '
b0 G
b0 S
b0 F
b0 a
b0 t
b0 #
b0 ;
b0 l
b0 D
b0 o
b0 %"
b0 &
b0 =
b0 Q
b0 *"
b0 J
b0 N
b0 &"
b0 C
b0 T
b0 m
b0 r
b0 $"
12
#20
1,
b1010111100000000100010111 /
b1010111100000000100010111 8
b1010111100000000100010111 _
b1010111100000000100010111 j
03
02
#25
b10101 g
b10 e
b10 h
b1010111100000000000000000 d
b11100000100000010100 f
bx '
bx G
bx S
b101011110000000010 c
b10 z
b10101 ~
b11100 }
bx C
bx T
bx m
bx r
bx $"
b0 A
b0 O
b0 |
b0 #"
b0 B
b0 L
b0 {
b0 ""
bx J
bx N
bx &"
bx &
bx =
bx Q
bx *"
b1010111100000000100010111 #
b1010111100000000100010111 ;
b1010111100000000100010111 l
b1010111100000000100010111 F
b1010111100000000100010111 a
b1010111100000000100010111 t
12
#30
b10101 Y
x!
x"
x$
bx H
bx Z
bx \
bx [
x%
b10101 >
b10101 W
b10101 /"
bx ?
bx X
bx )"
b10101 E
b10101 i
b10101 u
b10101 +"
b0 @
b0 p
b0 y
b0 !"
b0 (
b0 4
b0 V
b1 *
b1 6
b1 -"
b10 )
b10 5
b10 '"
b0 -
b0 7
b0 b
b0 1
b0 9
b0 w
10
0,
02
#35
0!
0%
0"
0$
b10101 [
b10101 H
b10101 Z
b10101 \
bx @
bx p
bx y
bx !"
bx K
bx R
bx '
bx G
bx S
b0 ?
b0 X
b0 )"
bx D
bx o
bx %"
bx I
bx ^
bx s
b0 &
b0 =
b0 Q
b0 *"
b0 J
b0 N
b0 &"
bx A
bx O
bx |
bx #"
bx B
bx L
bx {
bx ""
b0 C
b0 T
b0 m
b0 r
b0 $"
12
#40
1,
b10100000000000000110011 /
b10100000000000000110011 8
b10100000000000000110011 _
b10100000000000000110011 j
00
02
#45
b101 Y
b101 >
b101 W
b101 /"
b101 E
b101 i
b101 u
b101 +"
x!
x%
x"
x$
bx [
bx H
bx Z
bx \
b101 g
b0 e
b0 h
b10100000000000000000000 d
b100000000100 f
b10101 K
b10101 R
bx ?
bx X
bx )"
b1010000000000000 c
b0 z
b101 ~
b0 }
b10101 @
b10101 p
b10101 y
b10101 !"
bx C
bx T
bx m
bx r
bx $"
bx J
bx N
bx &"
bx &
bx =
bx Q
bx *"
b10101 I
b10101 ^
b10101 s
b0 D
b0 o
b0 %"
b10100000000000000110011 #
b10100000000000000110011 ;
b10100000000000000110011 l
b10100000000000000110011 F
b10100000000000000110011 a
b10100000000000000110011 t
12
#50
bx Y
x!
x%
x"
x$
bx [
bx H
bx Z
bx \
bx >
bx W
bx /"
b0 *
b0 6
b0 -"
0,
02
#55
bx @
bx p
bx y
bx !"
bx K
bx R
bx '
bx G
bx S
bx D
bx o
bx %"
bx I
bx ^
bx s
b0 B
b0 L
b0 {
b0 ""
b10101 C
b10101 T
b10101 m
b10101 r
b10101 $"
12
#60
02
